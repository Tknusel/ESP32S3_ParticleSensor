/*
  Particle Sensor Display with SdFat Card Logging and MQTT for SparkFun ESP32-S3 Thing Plus
  
  This sketch integrates a BMV080 particulate matter sensor with an OLED display,
  SD card logging, and MQTT data transmission for real-time air quality monitoring.
  
  Hardware Connections:
  - ESP32-S3 Thing Plus connected to BMV080 via I2C/QWIIC
  - ESP32-S3 Thing Plus connected to OLED display via I2C
  - SD card inserted in ESP32-S3 Thing Plus's onboard SD card slot
  - WiFi connection for MQTT data transmission
  
  Features:
  - Displays integer values for PM1, PM2.5, and PM10
  - Changes display based on pollution level
  - Blinking wind icon in high pollution state
  - Warning display when sensor is obstructed
  - Logs mean values of all readings during the logging interval
  - Creates a new CSV file every 24 hours
  - Auto-resets after ~49 days to prevent millis() overflow
  - RGB LED indicates pollution level (green, orange, red)
  - MQTT transmission of sensor data to broker
  
  Libraries required:
  - SparkFun_BMV080_Arduino_Library
  - U8g2lib
  - Wire
  - USB and USBCDC (for ESP32-S3)
  - SdFat (for improved SD card logging)
  - SPI (for SD card communication)
  - FastLED (for RGB LED control)
  - WiFi (for ESP32-S3)
  - ArduinoMqttClient
*/

#include "SparkFun_BMV080_Arduino_Library.h" // http://librarymanager/All#SparkFun_BMV080
#include <U8g2lib.h>
#include <Wire.h>
#include <USB.h>
#include <USBCDC.h>
#include <SPI.h>
#include "SdFat.h" // http://librarymanager/All#sdfat_exfat by Bill Greiman
#include <FastLED.h> // For controlling the onboard RGB LED
#include <WiFi.h>  // ESP32-S3 WiFi library
#include <ArduinoMqttClient.h>  // MQTT library

USBCDC USBSerial;
SparkFunBMV080 bmv080; // Create an instance of the BMV080 class
#define BMV080_ADDR 0x57  // SparkFun BMV080 Breakout defaults to 0x57

// WiFi and MQTT configuration
const char ssid[] = "your SSID";
const char pass[] = "your password";
const char broker[] = "your IP";
int port = 1883;
const char mqtt_username[] = "public";
const char mqtt_password[] = "public";

// Location and device identification - CHANGE LOCATION FOR EACH SENSOR!
const char location[] = "Office";        // Change to: "Workshop" for second sensor
const char device_type[] = "airsensor";  // Consistent device type

// MQTT topics with location/device/measurement structure
String topic_pm1;
String topic_pm25;
String topic_pm10;
String topic_status;
String topic_obstruction;

WiFiClient wifiClient;
MqttClient mqttClient(wifiClient);

// MQTT transmission settings
#define MQTT_INTERVAL 30000 // Send MQTT data every 30 seconds
unsigned long lastMqttTime = 0;
bool wifiConnected = false;
bool mqttConnected = false;

// SdFat setup with debugging enabled
SdFat SD;
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(12))

// SD card settings for SparkFun ESP32-S3 Thing Plus
#define SD_CS_PIN 33      // CS pin for SD cards on ESP32-S3 Thing Plus
#define SD_DETECT_PIN 48  // SD card detect pin specific to ESP32-S3 Thing Plus
#define SD_SCK_PIN 38     // SPI clock pin
#define SD_MISO_PIN 39    // SPI MISO pin (SDO)
#define SD_MOSI_PIN 34    // SPI MOSI pin (SDI)
#define LOG_INTERVAL 60000 // Log data every minute (60000 ms)
#define SAMPLING_INTERVAL 1000 // Sample sensor every second
unsigned long lastLogTime = 0;
unsigned long lastSampleTime = 0;
String logFileName = "";
bool sdCardAvailable = false;  // Flag to track if SD card is working

// RGB LED settings - CORRECTED PIN FOR ESP32-S3 THING PLUS
#define LED_PIN 46        // Onboard RGB LED pin on ESP32-S3 Thing Plus (CORRECTED)
#define NUM_LEDS 1        // Number of LEDs (just one onboard)
CRGB leds[NUM_LEDS];      // FastLED array to control the LED

// Colors for different pollution states
#define COLOR_LOW     CRGB(0, 255, 0)    // Green for good air quality
#define COLOR_MEDIUM  CRGB(255, 128, 0)  // Orange for medium pollution
#define COLOR_HIGH    CRGB(255, 0, 0)    // Red for high pollution
#define COLOR_ERROR   CRGB(255, 0, 255)  // Purple for sensor error/obstruction
#define COLOR_OFF     CRGB(0, 0, 0)      // Off state
#define COLOR_WIFI    CRGB(0, 0, 255)    // Blue for WiFi connecting

// Data collection for mean value calculation
#define MAX_SAMPLES (LOG_INTERVAL / SAMPLING_INTERVAL) // Maximum number of samples per logging interval
float pm1Samples[MAX_SAMPLES];
float pm25Samples[MAX_SAMPLES];
float pm10Samples[MAX_SAMPLES];
bool obstructionSamples[MAX_SAMPLES];
int sampleCount = 0;
int obstructionCount = 0; // Count how many readings showed obstruction

// Time tracking for daily file rotation and auto-reset
#define MILLIS_PER_DAY 86400000UL     // Number of milliseconds in a day (24 hours)
#define MILLIS_OVERFLOW 4294967295UL  // When millis() will overflow (49.7 days)
#define AUTO_RESET_TIME 4200000000UL  // Reset after ~48.6 days to avoid overflow issues
unsigned long startOfDayMillis = 0;   // When the current day started
unsigned long bootMillis = 0;         // When the system booted
unsigned int dayCounter = 0;          // Which day we're on since boot

// Initialize the display
// Make sure this matches your display type
U8G2_SSD1327_MIDAS_128X128_2_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// Store the sensor values as strings (for integers instead of floats)
char sensorValuePPM10[4] = "0";
char sensorValuePPM25[4] = "0";
char sensorValuePPM1[4] = "0";

// Threshold values for different display states
#define THRESHOLD_HIGH 30.0  // Open a Window! (high pollution)
#define THRESHOLD_MEDIUM 15.0  // Some Particles (medium pollution)
#define THRESHOLD_LOW 0.0  // Good Air! (low pollution)

// Variable to control wind icon blinking
bool showWindIcon = true;
unsigned long lastWindToggleTime = 0;
#define WIND_TOGGLE_INTERVAL 1000  // 1000ms = 1 second toggle

// Current sensor readings for display
float currentPM1 = 0;
float currentPM25 = 0;
float currentPM10 = 0;
bool currentObstructed = false;

// Static bitmap data declarations 
static const unsigned char image_Layer_7_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x08,0x08,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x80,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x40,0x00,0x00,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x84,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x44,0x00,0x00,0x08,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x80,0x10,0x00,0x02,0x80,0x20,0x80,0x10,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x21,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x04,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x01,0x00,0x00,0x01,0x08,0x00,0x44,0x00,0x00,0x04,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x11,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x04,0x08,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x01,0x40,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x82,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_Layer_8_bits[] = {0x00,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xfd,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0xc1,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9e,0x01,0xfc,0x07,0x00,0x00,0x00,0x00,0x00,0x80,0x87,0x01,0x80,0xff,0x00,0x00,0x00,0x00,0x00,0xc0,0x83,0x01,0x00,0xf8,0x0f,0x00,0x00,0x00,0x00,0xf0,0x80,0x01,0x00,0x00,0xff,0x01,0x00,0x00,0x00,0x78,0x80,0x01,0x00,0x00,0xf0,0x1f,0x00,0x00,0x00,0x1c,0x80,0x01,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x0f,0x80,0x01,0x00,0x00,0x00,0xe0,0x1f,0x00,0x80,0x03,0x80,0x01,0x00,0x00,0x00,0x00,0xfe,0x01,0xe0,0x01,0x80,0x01,0x00,0x00,0x00,0x00,0xe0,0x01,0xf0,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x86,0x01,0x3c,0x00,0x80,0x01,0x00,0x00,0x00,0x80,0x81,0x01,0x1e,0x00,0x80,0x01,0x00,0x00,0x00,0x0e,0x80,0x01,0x07,0x00,0x80,0x01,0x00,0x00,0x00,0x02,0x80,0x01,0x87,0x00,0x80,0x01,0x00,0x00,0x3c,0x00,0x80,0x01,0x83,0x03,0x80,0x01,0x00,0x40,0x00,0x00,0x80,0x01,0x03,0xc0,0x81,0x01,0x00,0x38,0x00,0x00,0x80,0x01,0x03,0x00,0x83,0x01,0x80,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0xc0,0x03,0x70,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0xe1,0x01,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0xe1,0x01,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x03,0x70,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0xc2,0x01,0x80,0x38,0x00,0x00,0x80,0x01,0x03,0xc0,0x83,0x01,0x00,0x60,0x04,0x00,0x80,0x01,0xc3,0x03,0x80,0x01,0x00,0x00,0x18,0x00,0x80,0x01,0x07,0x00,0x80,0x01,0x00,0x00,0x00,0x0e,0x80,0x01,0x0f,0x00,0x80,0x01,0x00,0x00,0x00,0x80,0x87,0x01,0x3c,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0xe0,0x01,0x78,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0xfe,0x01,0xe0,0x01,0x80,0x01,0x00,0x00,0x00,0xe0,0x1f,0x00,0xc0,0x03,0x80,0x01,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x0f,0x80,0x01,0x00,0x00,0xe0,0x3f,0x00,0x00,0x00,0x3c,0x80,0x01,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x78,0x80,0x01,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0xe0,0x81,0x01,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x80,0x83,0x01,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x8f,0x01,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0xe1,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_Layer_9_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x80,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x10,0x00,0x09,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x80,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x02,0x08,0x00,0x80,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x00,0x00,0x00,0x81,0x08,0x00,0x00,0x00,0x00,0x82,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x20,0x40,0x00,0x00,0x00,0x80,0x10,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x08,0x00,0x02,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x88,0x00,0x00,0x00,0x40,0x00,0x10,0x08,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x20,0x00,0x00,0x00,0x02,0x08,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x02,0x08,0x00,0x80,0x00,0x10,0x00,0x00,0x00,0x80,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x04,0x00,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x10,0x00,0x00,0x04,0x00,0x00,0x00,0x22,0x00,0x00,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x10,0x08,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x82,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x00,0x08,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x80,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_Particles4x4_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x08,0x08,0x00,0x01,0x00,0x01,0x00,0x00,0x01,0x80,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x80,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x40,0x00,0x00,0x00,0x08,0x00,0x40,0x00,0x00,0x00,0x84,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x44,0x00,0x00,0x08,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x80,0x10,0x00,0x02,0x80,0x20,0x80,0x10,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x21,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x04,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x04,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x01,0x08,0x00,0x01,0x00,0x00,0x01,0x08,0x00,0x44,0x00,0x00,0x04,0x00,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x11,0x00,0x00,0x00,0x00,0x01,0x02,0x02,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x04,0x08,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x01,0x40,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x82,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_ParticleCube4x4empty_bits[] = {0x00,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xfd,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0xc1,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x9e,0x01,0xfc,0x07,0x00,0x00,0x00,0x00,0x00,0x80,0x87,0x01,0x80,0xff,0x00,0x00,0x00,0x00,0x00,0xc0,0x83,0x01,0x00,0xf8,0x0f,0x00,0x00,0x00,0x00,0xf0,0x80,0x01,0x00,0x00,0xff,0x01,0x00,0x00,0x00,0x78,0x80,0x01,0x00,0x00,0xf0,0x1f,0x00,0x00,0x00,0x1c,0x80,0x01,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x0f,0x80,0x01,0x00,0x00,0x00,0xe0,0x1f,0x00,0x80,0x03,0x80,0x01,0x00,0x00,0x00,0x00,0xfe,0x01,0xe0,0x01,0x80,0x01,0x00,0x00,0x00,0x00,0xe0,0x01,0xf0,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x86,0x01,0x3c,0x00,0x80,0x01,0x00,0x00,0x00,0x80,0x81,0x01,0x1e,0x00,0x80,0x01,0x00,0x00,0x00,0x0e,0x80,0x01,0x07,0x00,0x80,0x01,0x00,0x00,0x00,0x02,0x80,0x01,0x87,0x00,0x80,0x01,0x00,0x00,0x3c,0x00,0x80,0x01,0x83,0x03,0x80,0x01,0x00,0x40,0x00,0x00,0x80,0x01,0x03,0xc0,0x81,0x01,0x00,0x38,0x00,0x00,0x80,0x01,0x03,0x00,0x83,0x01,0x80,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0xc0,0x03,0x70,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0xe1,0x01,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x81,0x00,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0xe1,0x01,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0x80,0x03,0x70,0x00,0x00,0x00,0x80,0x01,0x03,0x00,0xc2,0x01,0x80,0x38,0x00,0x00,0x80,0x01,0x03,0xc0,0x83,0x01,0x00,0x60,0x04,0x00,0x80,0x01,0xc3,0x03,0x80,0x01,0x00,0x00,0x18,0x00,0x80,0x01,0x07,0x00,0x80,0x01,0x00,0x00,0x00,0x0e,0x80,0x01,0x0f,0x00,0x80,0x01,0x00,0x00,0x00,0x80,0x87,0x01,0x3c,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0xe0,0x01,0x78,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0xfe,0x01,0xe0,0x01,0x80,0x01,0x00,0x00,0x00,0xe0,0x1f,0x00,0xc0,0x03,0x80,0x01,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x0f,0x80,0x01,0x00,0x00,0xe0,0x3f,0x00,0x00,0x00,0x3c,0x80,0x01,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x78,0x80,0x01,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0xe0,0x81,0x01,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x80,0x83,0x01,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x8f,0x01,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xbc,0xe1,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0xff,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_Particles4x4_1_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x80,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x20,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x10,0x00,0x09,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x80,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x02,0x08,0x00,0x80,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x08,0x08,0x00,0x00,0x00,0x81,0x08,0x00,0x00,0x00,0x00,0x82,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x20,0x40,0x00,0x00,0x00,0x80,0x10,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x08,0x00,0x02,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x10,0x88,0x00,0x00,0x00,0x40,0x00,0x10,0x08,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x20,0x20,0x00,0x00,0x00,0x02,0x08,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x02,0x08,0x00,0x80,0x00,0x10,0x00,0x00,0x00,0x80,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x80,0x08,0x00,0x00,0x00,0x00,0x00,0x08,0x04,0x00,0x00,0x00,0x00,0x40,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x01,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x10,0x00,0x00,0x04,0x00,0x00,0x00,0x22,0x00,0x00,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x42,0x10,0x08,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x82,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x88,0x00,0x08,0x00,0x10,0x00,0x00,0x00,0x00,0x01,0x00,0x80,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
static const unsigned char image_wind_5_512_2514588136_bits[] = {0x07,0x00,0x00,0xf0,0x0f,0x00,0x00,0x1f,0x00,0x00,0xfc,0x3f,0x00,0x00,0x7f,0x00,0x00,0xfe,0x7f,0xc0,0x03,0xff,0x01,0x80,0xff,0xff,0xc1,0x07,0xf8,0x03,0xc0,0x0f,0xf0,0x83,0x0f,0xe0,0x07,0xf0,0x07,0xc0,0x0f,0x1f,0xc0,0x3f,0xfe,0x01,0x80,0x3f,0x3e,0x00,0xff,0xff,0x00,0x00,0xff,0x7f,0x00,0xfe,0x3f,0x00,0x00,0xfc,0x7f,0x00,0xf8,0x1f,0x00,0x00,0xf8,0x7f,0x00,0x80,0x01,0x00,0x00,0x80,0x3f,0x00,0x00,0x00,0x00,0x00,0x80,0x1f,0x00,0x00,0x00,0x00,0x00,0xc0,0x0f,0x00,0x00,0x00,0x00,0x00,0xc0,0x07,0x00,0x00,0x00,0x00,0x00,0xc0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xf0,0x0f,0x00,0x00,0x1f,0x00,0x00,0xfc,0x3f,0x80,0x01,0x7f,0x00,0x00,0xff,0xff,0xc0,0x03,0xff,0x01,0x80,0x7f,0xfe,0xc1,0x07,0xf8,0x03,0xc0,0x0f,0xf0,0x83,0x0f,0xe0,0x0f,0xf0,0x03,0xc0,0x0f,0x1f,0xc0,0xff,0xff,0x01,0x80,0xff,0x3f,0x00,0xff,0xff,0x00,0x00,0xff,0x7f,0x00,0xfe,0x7f,0x00,0x00,0xfe,0x7f,0x00,0xf8,0x0f,0x00,0x00,0xf8,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x00,0x00,0x00,0x00,0x80,0x1f,0x00,0x00,0x00,0x00,0x00,0xc0,0x0f,0x00,0x00,0x00,0x00,0x00,0xc0,0x07,0x00,0x00,0x00,0x00,0x00,0x80,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xf0,0x0f,0x00,0x00,0x1f,0x00,0x00,0xfc,0x3f,0x80,0x01,0x7f,0x00,0x00,0xff,0xff,0xc0,0x03,0xfe,0x01,0x80,0x7f,0xfe,0xc1,0x07,0xf8,0x03,0xe0,0x0f,0xf0,0x83,0x0f,0xe0,0x0f,0xf8,0x03,0xc0,0x0f,0x1f,0xc0,0xff,0xff,0x01,0x80,0xff,0x3f,0x00,0xff,0xff,0x00,0x00,0xff,0x7f,0x00,0xfe,0x3f,0x00,0x00,0xfe,0x7f,0x00,0xf8,0x0f,0x00,0x00,0xf8,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x00,0x00,0x00,0x00,0x00,0x80,0x1f,0x00,0x00,0x00,0x00,0x00,0xc0,0x0f,0x00,0x00,0x00,0x00,0x00,0xc0,0x07,0x00,0x00,0x00,0x00,0x00,0x80,0x03};
static const unsigned char image_hazard_warning_bits[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3f,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x1f,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0xf0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x03,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x01,0xc0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x01,0xc0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x80,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3f,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0xfc,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x07,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0xe0,0x07,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x03,0xf0,0x0f,0xe0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03,0xf8,0x1f,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x01,0xfc,0x3f,0xc0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x01,0xfc,0x3f,0xc0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xfe,0x7f,0x80,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0xfe,0x7f,0x00,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7f,0x00,0xfe,0x7f,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x3f,0x00,0xfe,0x7f,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0xfe,0x7f,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0xfe,0x7f,0x00,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0xfe,0x7f,0x00,0xf8,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0xfe,0x3f,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0xfc,0x3f,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0xfc,0x3f,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03,0x00,0xfc,0x3f,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03,0x00,0xfc,0x3f,0x00,0xc0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x01,0x00,0xfc,0x3f,0x00,0xc0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x01,0x00,0xfc,0x3f,0x00,0x80,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0xfc,0x3f,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,0xfc,0x3f,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0xfc,0x3f,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0xf8,0x1f,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0xf8,0x1f,0x00,0x00,0xfc,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0xf8,0x1f,0x00,0x00,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x0f,0x00,0x00,0xf8,0x1f,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0xf8,0x1f,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x07,0x00,0x00,0xf8,0x1f,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0xf8,0x1f,0x00,0x00,0xe0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03,0x00,0x00,0xf8,0x1f,0x00,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x03,0x00,0x00,0xf8,0x0f,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0x01,0x00,0x00,0xf0,0x0f,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0xf0,0x0f,0x00,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0xfc,0x03,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0x00,0xe0,0x07,0x00,0x00,0x00,0xf8,0x03,0x00,0x00,0x00,0x00,0xe0,0x0f,0x00,0x00,0x00,0xc0,0x03,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0xfc,0x03,0x00,0x00,0x00,0x80,0x01,0x00,0x00,0x00,0xc0,0x1f,0x00,0x00,0x00,0x00,0xfc,0x01,0x00,0x00,0x00,0xe0,0x07,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0xf8,0x1f,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0xf8,0x1f,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0xf8,0x1f,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0x00,0x00,0xf8,0x1f,0x00,0x00,0x00,0x00,0xfe,0x01,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0x00,0xf8,0x1f,0x00,0x00,0x00,0x00,0xfc,0x01,0x00,0x00,0xc0,0x3f,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0xfc,0x03,0x00,0x00,0xe0,0x1f,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0xf8,0x07,0x00,0x00,0xe0,0x0f,0x00,0x00,0x00,0x00,0xc0,0x03,0x00,0x00,0x00,0x00,0xf0,0x07,0x00,0x00,0xf0,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x0f,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x0f,0x00,0x00,0xf8,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xe0,0x1f,0x00,0x00,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0xfc,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc0,0x3f,0x00,0x00,0xfe,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x7f,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x80,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x01,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x7f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};


// WiFi connection function
void connectToWiFi() {
  USBSerial.print("Attempting to connect to WiFi SSID: ");
  USBSerial.println(ssid);
  
  // Show WiFi connecting status on LED
  setLedColor(COLOR_WIFI);
  
  // Show WiFi connecting on display
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_profont11_tr);
    u8g2.drawStr(0, 20, "Connecting to WiFi...");
    u8g2.drawStr(0, 40, ssid);
  } while (u8g2.nextPage());
  
  WiFi.begin(ssid, pass);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(1000);
    USBSerial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    USBSerial.println("");
    USBSerial.println("WiFi connected!");
    USBSerial.print("IP address: ");
    USBSerial.println(WiFi.localIP());
    
    // Show success on display
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "WiFi Connected!");
      u8g2.drawStr(0, 40, WiFi.localIP().toString().c_str());
    } while (u8g2.nextPage());
    delay(2000);
  } else {
    wifiConnected = false;
    USBSerial.println("");
    USBSerial.println("WiFi connection failed!");
    
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "WiFi Failed!");
      u8g2.drawStr(0, 40, "Check credentials");
    } while (u8g2.nextPage());
    delay(2000);
  }
}

// MQTT connection function
void connectToMQTT() {
  if (!wifiConnected) return;
  
  USBSerial.print("Attempting to connect to MQTT broker: ");
  USBSerial.println(broker);
  
  mqttClient.setUsernamePassword(mqtt_username, mqtt_password);
  
  if (mqttClient.connect(broker, port)) {
    mqttConnected = true;
    USBSerial.println("Connected to MQTT broker!");
    
    // Show MQTT success on display
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "MQTT Connected!");
      u8g2.drawStr(0, 40, broker);
    } while (u8g2.nextPage());
    delay(2000);
  } else {
    mqttConnected = false;
    USBSerial.print("MQTT connection failed! Error code = ");
    USBSerial.println(mqttClient.connectError());
    
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "MQTT Failed!");
      u8g2.drawStr(0, 40, "Check broker");
    } while (u8g2.nextPage());
    delay(2000);
  }
}

// Function to send sensor data via MQTT
void sendMqttData() {
  if (!mqttConnected) return;
  
  // Ensure MQTT client is responsive
  mqttClient.poll();
  
  // Send PM1 data
  mqttClient.beginMessage(topic_pm1.c_str());
  mqttClient.print(currentPM1, 2);
  mqttClient.endMessage();
  
  // Send PM2.5 data
  mqttClient.beginMessage(topic_pm25.c_str());
  mqttClient.print(currentPM25, 2);
  mqttClient.endMessage();
  
  // Send PM10 data
  mqttClient.beginMessage(topic_pm10.c_str());
  mqttClient.print(currentPM10, 2);
  mqttClient.endMessage();
  
  // Send obstruction status
  mqttClient.beginMessage(topic_obstruction.c_str());
  mqttClient.print(currentObstructed ? "true" : "false");
  mqttClient.endMessage();
  
  // Send overall status
  String status = "normal";
  float maxReading = max(max(currentPM10, currentPM25), currentPM1);
  if (currentObstructed) {
    status = "obstructed";
  } else if (maxReading >= THRESHOLD_HIGH) {
    status = "high_pollution";
  } else if (maxReading >= THRESHOLD_MEDIUM) {
    status = "medium_pollution";
  } else {
    status = "good_air";
  }
  
  mqttClient.beginMessage(topic_status.c_str());
  mqttClient.print(status);
  mqttClient.endMessage();
  
  USBSerial.println("MQTT data sent from " + String(location) + "/" + String(device_type) + 
                   ": PM1=" + String(currentPM1, 2) + 
                   ", PM2.5=" + String(currentPM25, 2) + 
                   ", PM10=" + String(currentPM10, 2) + 
                   ", Status=" + status);
}

// Check WiFi and MQTT connections
void checkConnections() {
  // Check WiFi connection
  if (WiFi.status() != WL_CONNECTED) {
    if (wifiConnected) {
      USBSerial.println("WiFi connection lost! Attempting to reconnect...");
      wifiConnected = false;
      mqttConnected = false;
    }
    connectToWiFi();
  }
  
  // Check MQTT connection
  if (wifiConnected && !mqttClient.connected()) {
    if (mqttConnected) {
      USBSerial.println("MQTT connection lost! Attempting to reconnect...");
      mqttConnected = false;
    }
    connectToMQTT();
  }
}

// Initialize RGB LED
void setupRgbLed() {
  FastLED.addLeds<WS2812, LED_PIN, GRB>(leds, NUM_LEDS);
  FastLED.setBrightness(50);  // 50/255 brightness to not be too bright
  setLedColor(COLOR_OFF);     // Start with LED off
  delay(50);
  // Startup animation - blink white twice
  setLedColor(CRGB(50, 50, 50));
  FastLED.show();
  delay(200);
  setLedColor(COLOR_OFF);
  FastLED.show();
  delay(200);
  setLedColor(CRGB(50, 50, 50));
  FastLED.show();
  delay(200);
  setLedColor(COLOR_OFF);
  FastLED.show();
}

// Set the LED color
void setLedColor(CRGB color) {
  leds[0] = color;
  FastLED.show();
}

// Update LED color based on pollution level and connection status
void updateLedPollutionIndicator(float pm1, float pm25, float pm10, bool obstructed) {
  // If WiFi/MQTT not connected, show blue
  if (!wifiConnected) {
    setLedColor(COLOR_WIFI);
    return;
  }
  
  if (obstructed) {
    // Sensor obstructed - purple
    setLedColor(COLOR_ERROR);
    return;
  }
  
  // Get the highest reading for pollution level
  float maxReading = max(max(pm10, pm25), pm1);
  
  // Set color based on pollution level
  if (maxReading >= THRESHOLD_HIGH) {
    // High pollution - red
    setLedColor(COLOR_HIGH);
  } else if (maxReading >= THRESHOLD_MEDIUM) {
    // Medium pollution - orange
    setLedColor(COLOR_MEDIUM);
  } else {
    // Low pollution - green
    setLedColor(COLOR_LOW);
  }
}

// Forward declaration for software reset function
void softwareReset();

// Function to calculate mean of array of floats
float calculateMean(float* samples, int count) {
  if (count == 0) return 0.0;
  
  float sum = 0.0;
  for (int i = 0; i < count; i++) {
    sum += samples[i];
  }
  return sum / count;
}

// Reset the sample collection arrays
void resetSamples() {
  sampleCount = 0;
  obstructionCount = 0;
}

// Test file write/read for verification
bool testSDCardWrite() {
  USBSerial.println("Testing SD card write/read...");
  
  // Try to create a test file
  File testFile = SD.open("test.txt", O_WRITE | O_CREAT | O_TRUNC);
  if (!testFile) {
    USBSerial.println("Failed to create test file!");
    return false;
  }
  
  // Write to test file
  const char testStr[] = "This is a test file to verify SD card operation";
  if (testFile.write(testStr, strlen(testStr)) != strlen(testStr)) {
    USBSerial.println("Failed to write to test file!");
    testFile.close();
    return false;
  }
  
  // Make sure data is physically written to the card
  testFile.flush();
  testFile.close();
  
  // Now try to read it back
  testFile = SD.open("test.txt", O_READ);
  if (!testFile) {
    USBSerial.println("Failed to open test file for reading!");
    return false;
  }
  
  char readBuf[64] = {0};
  int bytesRead = testFile.read(readBuf, sizeof(readBuf) - 1);
  testFile.close();
  
  if (bytesRead <= 0) {
    USBSerial.println("Failed to read from test file!");
    return false;
  }
  
  USBSerial.print("Read from test file: ");
  USBSerial.println(readBuf);
  
  // Compare the read data with what we wrote
  if (strncmp(readBuf, testStr, strlen(testStr)) != 0) {
    USBSerial.println("Test file content mismatch!");
    return false;
  }
  
  USBSerial.println("SD card write/read test passed!");
  return true;
}

// List files in the root directory
void listRootDirectory() {
  USBSerial.println("Files found on SD card:");
  USBSerial.println("=======================");
  
  File root = SD.open("/");
  if (!root) {
    USBSerial.println("Failed to open root directory!");
    return;
  }
  
  File file = root.openNextFile();
  int fileCount = 0;
  
  while (file) {
    fileCount++;
    char fileName[256];
    file.getName(fileName, sizeof(fileName));
    
    // Print file info
    USBSerial.print(fileName);
    USBSerial.print("\t");
    
    if (file.isDirectory()) {
      USBSerial.println(" [DIR]");
    } else {
      // Print file size
      USBSerial.print(file.size());
      USBSerial.println(" bytes");
    }
    
    file.close();
    file = root.openNextFile();
  }
  
  root.close();
  
  if (fileCount == 0) {
    USBSerial.println("No files found!");
  }
  USBSerial.println("=======================");
}

// Function to perform a software reset
void softwareReset() {
  USBSerial.println("\n\n*** PERFORMING AUTO-RESET AFTER 48+ DAYS TO PREVENT MILLIS OVERFLOW ***");
  USBSerial.println("*** SYSTEM WILL RESTART IN 5 SECONDS ***");
  
  // Display reset notice
  u8g2.firstPage();
  do {
    u8g2.setFont(u8g2_font_profont11_tr);
    u8g2.drawStr(0, 20, "AUTO-RESET");
    u8g2.drawStr(0, 40, "System will restart");
    u8g2.drawStr(0, 60, "in 5 seconds...");
  } while (u8g2.nextPage());
  
  // Give some time for messages and display
  delay(5000);
  
  // Perform the actual reset
  ESP.restart();
}

// Check if a day has passed and we need to create a new log file
bool checkDayChange() {
  unsigned long currentMillis = millis();
  
  // Calculate how long we've been running today
  unsigned long todayRuntime = currentMillis - startOfDayMillis;
  
  // If we've been running for more than a day, it's time for a new file
  if (todayRuntime >= MILLIS_PER_DAY) {
    dayCounter++;
    startOfDayMillis = currentMillis;
    return true;
  }
  
  return false;
}

// Check if we're approaching millis() overflow and need to reset
bool checkAutoReset() {
  // If we're beyond our auto-reset threshold
  if (millis() >= AUTO_RESET_TIME) {
    return true;
  }
  return false;
}

// Function to check and handle SD card insertion/removal
void handleSDCardHotSwap() {
  static bool lastCardState = false;
  bool currentCardState = digitalRead(SD_DETECT_PIN) == HIGH;
  
  // Card state changed
  if (currentCardState != lastCardState) {
    if (currentCardState) {
      // Card inserted
      USBSerial.println("SD card inserted! Attempting to reinitialize...");
      
      // Complete SD card reinitialization sequence:
      
      // 1. End current SD operations completely
      SD.end();
      
      // 2. Delay to allow card to stabilize
      delay(500);
      
      // 3. Reinitialize SPI bus with correct pins
      SPI.end(); // End current SPI configuration
      delay(100);
      SPI.begin(SD_SCK_PIN, SD_MISO_PIN, SD_MOSI_PIN, SD_CS_PIN);
      delay(100);
      
      // 4. Attempt to initialize SD with progressively slower speeds if needed
      uint32_t spiSpeeds[] = {12, 8, 4}; // MHz
      bool initSuccess = false;
      
      for (int i = 0; i < 3 && !initSuccess; i++) {
        USBSerial.print("Trying SPI speed ");
        USBSerial.print(spiSpeeds[i]);
        USBSerial.println(" MHz...");
        
        SdSpiConfig config(SD_CS_PIN, DEDICATED_SPI, SD_SCK_MHZ(spiSpeeds[i]));
        initSuccess = SD.begin(config);
        
        if (initSuccess) {
          USBSerial.println("SD initialization successful!");
          break;
        }
        
        // Short delay before trying next speed
        delay(200);
      }
      
      // 5. Try one last time with software SPI if hardware SPI fails
      if (!initSuccess) {
        USBSerial.println("Trying with software SPI fallback...");
        SdSpiConfig softConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(4));
        initSuccess = SD.begin(softConfig);
      }
      
      // 6. Test if we can actually use the card
      if (initSuccess) {
        sdCardAvailable = testSDCardWrite();
        
        if (sdCardAvailable) {
          createLogFile();
          USBSerial.println("SD card is ready for logging");
        } else {
          USBSerial.println("SD card test failed - card may be faulty or write-protected");
        }
      } else {
        USBSerial.print("SD initialization failed. Error code: ");
        USBSerial.println(SD.sdErrorCode());
        sdCardAvailable = false;
      }
    } else {
      // Card removed
      USBSerial.println("SD card removed!");
      if (sdCardAvailable) {
        SD.end(); // Properly end SD card operations
        sdCardAvailable = false;
      }
    }
    
    lastCardState = currentCardState;
  }
}

void setup() {
  // Initialize USB and USB CDC
  USB.begin();
  USBSerial.begin();
  
  // Wait for USB CDC to initialize
  delay(2000);

  // Record our boot time
  bootMillis = millis();
  startOfDayMillis = bootMillis;

  USBSerial.println();
  USBSerial.println("BMV080 Particle Sensor with Display, SdFat Logging, and MQTT");
  USBSerial.println("With mean value calculation, daily rotation, auto-reset, and WiFi/MQTT");
  USBSerial.print("Location: ");
  USBSerial.println(location);
  USBSerial.print("Device Type: ");
  USBSerial.println(device_type);

  // Build MQTT topics with location/device/measurement structure
  topic_pm1 = String(location) + "/" + String(device_type) + "/pm1";
  topic_pm25 = String(location) + "/" + String(device_type) + "/pm25";
  topic_pm10 = String(location) + "/" + String(device_type) + "/pm10";
  topic_status = String(location) + "/" + String(device_type) + "/status";
  topic_obstruction = String(location) + "/" + String(device_type) + "/obstruction";
  
  USBSerial.println("MQTT Topics:");
  USBSerial.println("  " + topic_pm1);
  USBSerial.println("  " + topic_pm25);
  USBSerial.println("  " + topic_pm10);
  USBSerial.println("  " + topic_status);
  USBSerial.println("  " + topic_obstruction);

  // Initialize I2C with slower clock speed (ONCE)
  Wire.begin();
  Wire.setClock(100000); // 100 kHz for better reliability
  
  // Initialize display (ONCE)
  bool displaySuccess = u8g2.begin();
  delay(200); // Give display time to initialize fully
  
  USBSerial.print("Display initialization: ");
  USBSerial.println(displaySuccess ? "SUCCESS" : "FAILURE");
  
  // Initialize the RGB LED early
  setupRgbLed();
  
  // Connect to WiFi
  connectToWiFi();
  
  // Connect to MQTT broker
  if (wifiConnected) {
    connectToMQTT();
  }
  
  // Initialize SD card detect pin
  pinMode(SD_DETECT_PIN, INPUT_PULLDOWN);
  
  // Check if SD card is inserted
  bool sdCardInserted = digitalRead(SD_DETECT_PIN) == HIGH;
  USBSerial.print("SD card ");
  USBSerial.println(sdCardInserted ? "detected!" : "not present!");
  
  // Initialize SPI bus for SD card with explicit pin definitions
  SPI.begin(SD_SCK_PIN, SD_MISO_PIN, SD_MOSI_PIN, SD_CS_PIN);
  
  if (sdCardInserted) {
    // Initialize SD card with SdFat - using lower 12.5MHz speed for better compatibility
    USBSerial.print("Initializing SD card with SdFat...");
    
    // Initialize with error checking
    if (!SD.begin(SD_CONFIG)) {
      USBSerial.print("FAILED! Error code: ");
      USBSerial.println(SD.sdErrorCode());
      
      // Show SD card error on display
      u8g2.firstPage();
      do {
        u8g2.setFont(u8g2_font_profont11_tr);
        u8g2.drawStr(0, 20, "SD Card Init Failed!");
        u8g2.drawStr(0, 40, "Error code:");
        char errStr[16];
        sprintf(errStr, "%d", SD.sdErrorCode());
        u8g2.drawStr(80, 40, errStr);
      } while (u8g2.nextPage());
      delay(2000);
    } else {
      USBSerial.println("SUCCESS!");
      
      // Test SD card operations
      sdCardAvailable = testSDCardWrite();
      
      if (sdCardAvailable) {
        // List files in root directory to verify card is working
        listRootDirectory();
        
        // Now create our log file
        createLogFile();
      } else {
        USBSerial.println("SD card test failed!");
        u8g2.firstPage();
        do {
          u8g2.setFont(u8g2_font_profont11_tr);
          u8g2.drawStr(0, 20, "SD Card Test Failed!");
          u8g2.drawStr(0, 40, "Check card format");
          u8g2.drawStr(0, 60, "and connections");
        } while (u8g2.nextPage());
        delay(2000);
      }
    }
  } else {
    // No SD card detected
    USBSerial.println("No SD card inserted.");
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "No SD Card Detected");
      u8g2.drawStr(0, 40, "Data logging disabled");
      u8g2.drawStr(0, 60, "Insert card & restart");
    } while (u8g2.nextPage());
    delay(2000);
  }
  
  // Check if sensor is connected
  if (bmv080.begin(BMV080_ADDR, Wire) == false) {
    USBSerial.println("BMV080 not detected. Check connections. Freezing...");
    
    // Use page buffer mode here too
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "Sensor Not Found!");
    } while (u8g2.nextPage());
    
    while (1) {
      delay(1000);
      USBSerial.println("Still waiting for BMV080...");
    }
  }
  
  USBSerial.println("BMV080 found!");

  // Initialize the sensor
  USBSerial.println("Initializing BMV080...");
  bmv080.init();
  USBSerial.println("Initialization complete");

  // Set sensor to continuous mode
  if (bmv080.setMode(SF_BMV080_MODE_CONTINUOUS)) {
    USBSerial.println("BMV080 set to continuous mode");
  } else {
    USBSerial.println("Error setting BMV080 mode");
  }
  
  // Initialize sample arrays
  resetSamples();
  
  // Test the LED with appropriate color based on connection status
  updateLedPollutionIndicator(0, 0, 0, false);
  
  USBSerial.println("Setup complete");
  USBSerial.println("Sampling interval: " + String(SAMPLING_INTERVAL) + "ms");
  USBSerial.println("Logging interval: " + String(LOG_INTERVAL) + "ms");
  USBSerial.println("MQTT interval: " + String(MQTT_INTERVAL) + "ms");
  USBSerial.println("Samples per log: " + String(MAX_SAMPLES));
}

// Function to create a log file with a unique name based on boot count and day
void createLogFile() {
  if (!sdCardAvailable) return;  // Skip if SD card isn't working
  
  // Create a new file with timestamp or boot count
  // First, check if a boot counter file exists
  int bootCount = 1;
  
  // Remove leading slash for better compatibility
  File countFile;
  if (SD.exists("bootcount.txt")) {
    countFile = SD.open("bootcount.txt", O_READ);
    if (countFile) {
      char countStr[10] = {0};
      countFile.read(countStr, sizeof(countStr) - 1);
      bootCount = atoi(countStr) + 1;
      countFile.close();
      USBSerial.print("Found existing boot count file, incremented to: ");
      USBSerial.println(bootCount);
    }
  } else {
    USBSerial.println("Boot count file doesn't exist, creating new one");
  }
  
  // Update the boot count with explicit open/close/flush
  countFile = SD.open("bootcount.txt", O_WRITE | O_CREAT | O_TRUNC);
  if (countFile) {
    char countStr[10];
    sprintf(countStr, "%d", bootCount);
    
    if (countFile.write(countStr, strlen(countStr)) != strlen(countStr)) {
      USBSerial.println("Error writing to boot count file!");
    }
    
    // Ensure data is written to card
    countFile.flush();
    countFile.close();
    
    // Ensure the file system is properly updated
    SD.vol()->freeClusterCount();
    
    USBSerial.print("Updated boot count to: ");
    USBSerial.println(bootCount);
  } else {
    USBSerial.println("Failed to open boot count file for writing!");
    USBSerial.print("Error: ");
    USBSerial.println(SD.sdErrorCode());
    return;
  }
  
  // Create a new log file using the boot count and day counter
  char fileNameBuffer[32];
  sprintf(fileNameBuffer, "airdata_%d_%d.csv", bootCount, dayCounter);
  logFileName = String(fileNameBuffer);
  
  // Write CSV header with explicit flush
  File dataFile = SD.open(logFileName.c_str(), O_WRITE | O_CREAT | O_TRUNC);
  if (dataFile) {
    USBSerial.print("Writing header to log file: ");
    USBSerial.println(logFileName);
    
    const char* header = "Timestamp,PM1_Mean,PM2.5_Mean,PM10_Mean,ObstructionPercent,SampleCount\n";
    
    if (dataFile.write(header, strlen(header)) != strlen(header)) {
      USBSerial.println("Error writing header to log file!");
    }
    
    // Ensure data is written to card
    dataFile.flush();
    dataFile.close();
    
    // Ensure the file system is properly updated
    SD.vol()->freeClusterCount();
    
    // Verify the file was created by listing directory again
    listRootDirectory();
    
    USBSerial.println("Created log file: " + logFileName);
    
    // Show message on display temporarily
    u8g2.firstPage();
    do {
      u8g2.setFont(u8g2_font_profont11_tr);
      u8g2.drawStr(0, 20, "SD Card Ready");
      u8g2.drawStr(0, 40, logFileName.c_str());
    } while (u8g2.nextPage());
    delay(1500);
  } else {
    USBSerial.println("Error creating log file!");
    USBSerial.print("Error code: ");
    USBSerial.println(SD.sdErrorCode());
    sdCardAvailable = false;  // Mark SD card as unavailable if we can't create files
  }
}

// Function to log mean data to SD card
void logMeanDataToSD() {
  if (!sdCardAvailable || logFileName.length() == 0) return; // Skip if SD card isn't working or no filename
  
  // Calculate mean values
  float meanPM1 = calculateMean(pm1Samples, sampleCount);
  float meanPM25 = calculateMean(pm25Samples, sampleCount);
  float meanPM10 = calculateMean(pm10Samples, sampleCount);
  float obstructionPercent = 0;
  
  if (sampleCount > 0) {
    obstructionPercent = (float)obstructionCount * 100.0 / sampleCount;
  }
  
  // Open the file for appending - no leading slash
  File dataFile = SD.open(logFileName.c_str(), O_WRITE | O_APPEND);
  
  if (dataFile) {
    // Create buffer for data line with mean values
    char dataBuffer[100];
    sprintf(dataBuffer, "%lu,%.2f,%.2f,%.2f,%.1f,%d\n", 
            millis(), meanPM1, meanPM25, meanPM10, obstructionPercent, sampleCount);
    
    // Write the data with error checking
    size_t bytesWritten = dataFile.write(dataBuffer, strlen(dataBuffer));
    
    if (bytesWritten != strlen(dataBuffer)) {
      USBSerial.print("Warning: Only wrote ");
      USBSerial.print(bytesWritten);
      USBSerial.print(" of ");
      USBSerial.print(strlen(dataBuffer));
      USBSerial.println(" bytes");
    }
    
    // Ensure data is actually written to the card
    dataFile.flush();
    dataFile.close();
    
    // Sync volume occasionally to ensure FAT and directory structure is updated
    static int syncCounter = 0;
    if (++syncCounter >= 10) {
      syncCounter = 0;
      SD.vol()->freeClusterCount();
    }
    
    // Show brief logging indicator on serial
    USBSerial.print("Mean data logged to SD: ");
    USBSerial.println(dataBuffer);
    
    // Reset sample counters after logging
    resetSamples();
  } else {
    USBSerial.print("Error opening log file! Error code: ");
    USBSerial.println(SD.sdErrorCode());
    sdCardAvailable = false;  // Mark SD card as unavailable if we can't write
  }
}

// Add a new sensor reading to the sample arrays
void addSample(float pm1, float pm25, float pm10, bool obstructed) {
  if (sampleCount < MAX_SAMPLES) {
    pm1Samples[sampleCount] = pm1;
    pm25Samples[sampleCount] = pm25;
    pm10Samples[sampleCount] = pm10;
    obstructionSamples[sampleCount] = obstructed;
    
    if (obstructed) {
      obstructionCount++;
    }
    
    sampleCount++;
  }
}

// Function to display "Open a Window!" (high pollution) screen
void displayHighPollution() {
  // Check if it's time to toggle the wind icon visibility
  unsigned long currentTime = millis();
  if (currentTime - lastWindToggleTime >= WIND_TOGGLE_INTERVAL) {
    showWindIcon = !showWindIcon;  // Toggle the visibility state
    lastWindToggleTime = currentTime;
  }
  
  u8g2.firstPage();
  do {
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    
    // Draw text elements
    u8g2.setFont(u8g2_font_profont11_tr);
    u8g2.drawStr(0, 8, "PPM10:");
    u8g2.drawStr(72, 30, "PPM1:");
    u8g2.drawStr(33, 19, "PPM2.5:");
    
    // Draw lines
    u8g2.drawLine(35, 9, 128, 9);
    u8g2.drawLine(74, 20, 128, 20);
    u8g2.drawLine(102, 31, 128, 31);
    
    // Draw bitmaps one at a time with small delays
    u8g2.drawXBM(-1, 28, 73, 71, image_Layer_7_bits);
    u8g2.drawXBM(0, 29, 73, 71, image_Layer_8_bits);
    u8g2.drawXBM(1, 30, 71, 69, image_Layer_9_bits);
    
    // Draw wind icon only if the toggle state is true
    if (showWindIcon) {
      u8g2.drawXBM(66, 43, 55, 51, image_wind_5_512_2514588136_bits);
    }
    
    // Draw labels and values
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(4, 119, "Open a Window!");
    
    u8g2.setFont(u8g2_font_profont10_tr);
    u8g2.drawStr(111, 8, sensorValuePPM10);
    u8g2.drawStr(111, 18, sensorValuePPM25);
    u8g2.drawStr(111, 29, sensorValuePPM1);
    
    // Show WiFi/MQTT status
    if (wifiConnected && mqttConnected) {
      u8g2.drawStr(0, 128, "MQTT");
    } else if (wifiConnected) {
      u8g2.drawStr(0, 128, "WiFi");
    }
  } while (u8g2.nextPage());
}

// Function to display "Some Particles" (medium pollution) screen
void displayMediumPollution() {
  u8g2.firstPage();
  do {
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    u8g2.setFont(u8g2_font_profont11_tr);
    
    u8g2.drawStr(0, 8, "PPM10:");
    u8g2.drawStr(72, 30, "PPM1:");
    u8g2.drawStr(33, 19, "PPM2.5:");
    
    u8g2.drawLine(35, 9, 128, 9);
    u8g2.drawLine(74, 20, 128, 20);
    u8g2.drawLine(102, 31, 128, 31);
    
    // Draw bitmaps for medium pollution
    u8g2.drawXBM(-1, 28, 73, 71, image_Particles4x4_bits);
    u8g2.drawXBM(1, 29, 73, 71, image_ParticleCube4x4empty_bits);
    
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(4, 119, "Some Particles");
    
    // Display sensor values
    u8g2.setFont(u8g2_font_profont10_tr);
    u8g2.drawStr(111, 8, sensorValuePPM10);
    u8g2.drawStr(111, 18, sensorValuePPM25);
    u8g2.drawStr(111, 29, sensorValuePPM1);
    
    // Show WiFi/MQTT status
    if (wifiConnected && mqttConnected) {
      u8g2.drawStr(0, 128, "MQTT");
    } else if (wifiConnected) {
      u8g2.drawStr(0, 128, "WiFi");
    }
  } while (u8g2.nextPage());
}

void displayLowPollution() {
  u8g2.firstPage();
  do {
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    u8g2.setFont(u8g2_font_profont11_tr);
    
    u8g2.drawStr(0, 8, "PPM10:");
    u8g2.drawStr(72, 30, "PPM1:");
    u8g2.drawStr(33, 19, "PPM2.5:");
    
    u8g2.drawLine(35, 9, 128, 9);
    u8g2.drawLine(74, 20, 128, 20);
    u8g2.drawLine(102, 31, 128, 31);
    
    // Draw bitmap for good air
    u8g2.drawXBM(1, 29, 73, 71, image_ParticleCube4x4empty_bits);
    
    u8g2.setFont(u8g2_font_profont17_tr);
    u8g2.drawStr(4, 119, "Good Air!");
    
    // Display sensor values
    u8g2.setFont(u8g2_font_profont10_tr);
    u8g2.drawStr(111, 8, sensorValuePPM10);
    u8g2.drawStr(111, 18, sensorValuePPM25);
    u8g2.drawStr(111, 29, sensorValuePPM1);
    
    // Show WiFi/MQTT status
    if (wifiConnected && mqttConnected) {
      u8g2.drawStr(0, 128, "MQTT");
    } else if (wifiConnected) {
      u8g2.drawStr(0, 128, "WiFi");
    }
  } while (u8g2.nextPage());
}

// Function to display sensor obstructed warning
void displaySensorObstructed() {
  u8g2.firstPage();
  do {
    u8g2.setFontMode(1);
    u8g2.setBitmapMode(1);
    
    // Draw hazard warning symbol
    u8g2.drawXBM(-1, -12, 128, 128, image_hazard_warning_bits);
    
    // Draw warning text
    u8g2.setFont(u8g2_font_profont15_tr);
    u8g2.drawStr(5, 119, "Sensor Obstructed");
    
    // Show WiFi/MQTT status
    u8g2.setFont(u8g2_font_profont10_tr);
    if (wifiConnected && mqttConnected) {
      u8g2.drawStr(0, 8, "MQTT Connected");
    } else if (wifiConnected) {
      u8g2.drawStr(0, 8, "WiFi Connected");
    } else {
      u8g2.drawStr(0, 8, "No WiFi");
    }
  } while (u8g2.nextPage());
}

void loop() {
  unsigned long currentMillis = millis();
  
  // Check if we need to auto-reset to prevent millis overflow
  if (checkAutoReset()) {
    softwareReset();
    // The code will not reach here as the system will restart
  }
  
  // Check WiFi and MQTT connections periodically
  static unsigned long lastConnectionCheck = 0;
  if (currentMillis - lastConnectionCheck >= 30000) { // Check every 30 seconds
    lastConnectionCheck = currentMillis;
    checkConnections();
  }
  
  // Keep MQTT client responsive
  if (mqttConnected) {
    mqttClient.poll();
  }
  
  // Check if we need to create a new file for a new day
  if (sdCardAvailable && checkDayChange()) {
    USBSerial.println("\n*** 24 HOURS PASSED - CREATING NEW LOG FILE ***");
    // Log any remaining data before creating a new file
    if (sampleCount > 0) {
      logMeanDataToSD();
    }
    createLogFile();
  }
  
  // Sample the sensor at regular intervals
  if (currentMillis - lastSampleTime >= SAMPLING_INTERVAL) {
    lastSampleTime = currentMillis;
    
    // Read data from sensor
    if (bmv080.readSensor()) {
      // Get sensor readings as floats
      currentPM10 = bmv080.PM10();
      currentPM25 = bmv080.PM25();
      currentPM1 = bmv080.PM1();
      currentObstructed = bmv080.isObstructed();
      
      // Add this reading to our samples
      addSample(currentPM1, currentPM25, currentPM10, currentObstructed);
      
      // Log readings to serial monitor
      USBSerial.print("PM10: ");
      USBSerial.print(currentPM10);
      USBSerial.print("\t");
      USBSerial.print("PM2.5: ");
      USBSerial.print(currentPM25);
      USBSerial.print("\t");
      USBSerial.print("PM1: ");
      USBSerial.print(currentPM1);
      
      if (currentObstructed) {
        USBSerial.print("\tObstructed");
      }
      
      // Show SD card status in serial output
      bool sdCardInserted = digitalRead(SD_DETECT_PIN) == HIGH;
      USBSerial.print("\tSD: ");
      if (sdCardInserted) {
        USBSerial.print(sdCardAvailable ? "OK" : "Init Failed");
      } else {
        USBSerial.print("Not Inserted");
      }
      
      // Show WiFi/MQTT status
      USBSerial.print("\tWiFi: ");
      USBSerial.print(wifiConnected ? "OK" : "NO");
      USBSerial.print("\tMQTT: ");
      USBSerial.print(mqttConnected ? "OK" : "NO");
      
      // Show sample count and runtime information
      unsigned long uptime = millis();
      unsigned long dayRuntime = uptime - startOfDayMillis;
      USBSerial.print("\tSamples: ");
      USBSerial.print(sampleCount);
      USBSerial.print("/");
      USBSerial.print(MAX_SAMPLES);
      USBSerial.print("\tDay: ");
      USBSerial.print(dayCounter);
      USBSerial.print(" (");
      USBSerial.print(dayRuntime / 3600000); // Hours
      USBSerial.print("h)");
      
      USBSerial.println();
      
      // Convert float values to integers and then to strings for display
      int pm10Int = (int)currentPM10;
      int pm25Int = (int)currentPM25;
      int pm1Int = (int)currentPM1;
      
      // Format sensor values as integer strings
      snprintf(sensorValuePPM10, 4, "%d", pm10Int);
      snprintf(sensorValuePPM25, 4, "%d", pm25Int);
      snprintf(sensorValuePPM1, 4, "%d", pm1Int);
      
      // Update display based on sensor state and readings
      if (currentObstructed) {
        displaySensorObstructed();
      } else {
        // Choose display based on highest reading
        float maxReading = max(max(currentPM10, currentPM25), currentPM1);
        
        if (maxReading >= THRESHOLD_HIGH) {
          displayHighPollution();
        } else if (maxReading >= THRESHOLD_MEDIUM) {
          displayMediumPollution();
        } else {
          displayLowPollution();
        }
      }
      
      // Update the RGB LED based on pollution status and connection
      updateLedPollutionIndicator(currentPM1, currentPM25, currentPM10, currentObstructed);
      
    } else {
      USBSerial.println("Failed to read sensor data");
      
      // Display error message when sensor reading fails
      u8g2.firstPage();
      do {
        u8g2.setFont(u8g2_font_profont11_tr);
        u8g2.drawStr(0, 20, "Sensor Read Error");
        u8g2.drawStr(0, 40, "Check connections");
        u8g2.drawStr(0, 60, "Retrying...");
        
        // Show connection status even during error
        if (wifiConnected && mqttConnected) {
          u8g2.drawStr(0, 80, "MQTT: Connected");
        } else if (wifiConnected) {
          u8g2.drawStr(0, 80, "WiFi: Connected");
        } else {
          u8g2.drawStr(0, 80, "WiFi: Disconnected");
        }
      } while (u8g2.nextPage());
      
      // Update LED to error state
      setLedColor(COLOR_ERROR);
      
      delay(500); // Shorter delay when there's an error to not miss too many samples
    }
  }
  
  // Check if it's time to log the data (mean values)
  if (currentMillis - lastLogTime >= LOG_INTERVAL && sampleCount > 0) {
    lastLogTime = currentMillis;
    logMeanDataToSD();
  }
  
  // Check if it's time to send MQTT data
  if (currentMillis - lastMqttTime >= MQTT_INTERVAL) {
    lastMqttTime = currentMillis;
    sendMqttData();
  }
  
  // Check and handle SD card hot-swapping
  handleSDCardHotSwap();
  
  // Small delay to prevent excessive CPU usage and give other tasks time
  delay(10);
}